{"ast":null,"code":"/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\nimport { ENGINE } from '../engine';\nimport { assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray } from '../util';\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(values, shape, inferredShape, dtype) {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(`Cannot construct a complex64 tensor directly. ` + `Please use tf.complex(real, imag).`);\n  }\n  if (typeof values === 'object' && 'texture' in values) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(`Creating tensor from texture only supports ` + `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    values.channels = values.channels || 'RGBA';\n    return ENGINE.backend.createTensorFromTexture(values, shape || inferredShape, dtype);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) && typeof values !== 'number' && typeof values !== 'boolean' && typeof values !== 'string') {\n    throw new Error('values passed to tensor(values) must be a number/boolean/string or ' + 'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(providedSize === inferredSize, () => `Based on the provided shape, [${shape}], the tensor should have ` + `${providedSize} values but has ${inferredSize}`);\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ? inferred !== sizeFromShape(shape.slice(i)) : true;\n      assert(inferredShape[i] === shape[i] || !flatDimsDontMatch, () => `Error creating a new Tensor. Inferred shape ` + `(${inferredShape}) does not match the provided ` + `shape (${shape}). `);\n    }\n  }\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values];\n  }\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ? toTypedArray(values, dtype) : flatten(values, [], true);\n  return ENGINE.makeTensor(values, shape, dtype);\n}","map":{"version":3,"mappings":"AAAA;;;;;;;;;;;;;;;;AAiBA,SAAQA,MAAM,QAAO,WAAW;AAIhC,SAAQC,MAAM,EAAEC,kCAAkC,EAAEC,OAAO,EAAEC,UAAU,EAAEC,YAAY,EAAEC,aAAa,EAAEC,YAAY,QAAO,SAAS;AAElI;AACA,OAAM,SAAUC,UAAU,CACtBC,MAA4B,EAAEC,KAAe,EAAEC,aAAuB,EACtEC,KAAgB;EAClB,IAAIA,KAAK,IAAI,IAAI,EAAE;IACjBA,KAAK,GAAGR,UAAU,CAACK,MAAM,CAAC;;EAE5B,IAAIG,KAAK,KAAK,WAAW,EAAE;IACzB,MAAM,IAAIC,KAAK,CACX,gDAAgD,GAChD,oCAAoC,CAAC;;EAE3C,IAAI,OAAOJ,MAAM,KAAK,QAAQ,IAAI,SAAS,IAAIA,MAAM,EAAE;IACrD,IAAIG,KAAK,KAAK,SAAS,IAAIA,KAAK,KAAK,OAAO,EAAE;MAC5C,MAAM,IAAIC,KAAK,CACX,6CAA6C,GAC7C,+CAA+CD,KAAK,GAAG,CAAC;;IAE9DH,MAAM,CAACK,QAAQ,GAAGL,MAAM,CAACK,QAAQ,IAAI,MAAM;IAC3C,OAAOd,MAAM,CAACe,OAAO,CAACC,uBAAuB,CACzCP,MAAM,EAAEC,KAAK,IAAIC,aAAa,EAAEC,KAAK,CAAC;;EAE5C,IAAI,CAACP,YAAY,CAACI,MAAM,CAAC,IAAI,CAACQ,KAAK,CAACC,OAAO,CAACT,MAAM,CAAC,IAC/C,OAAOA,MAAM,KAAK,QAAQ,IAAI,OAAOA,MAAM,KAAK,SAAS,IACzD,OAAOA,MAAM,KAAK,QAAQ,EAAE;IAC9B,MAAM,IAAII,KAAK,CACX,qEAAqE,GACrE,uDAAuD,CAAC;;EAE9D;EACA,IAAIH,KAAK,IAAI,IAAI,EAAE;IACjBR,kCAAkC,CAACQ,KAAK,CAAC;IAEzC,MAAMS,YAAY,GAAGb,aAAa,CAACI,KAAK,CAAC;IACzC,MAAMU,YAAY,GAAGd,aAAa,CAACK,aAAa,CAAC;IACjDV,MAAM,CACFkB,YAAY,KAAKC,YAAY,EAC7B,MACI,iCAAiCV,KAAK,4BAA4B,GAClE,GAAGS,YAAY,mBAAmBC,YAAY,EAAE,CAAC;IAEzD,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGV,aAAa,CAACW,MAAM,EAAE,EAAED,CAAC,EAAE;MAC7C,MAAME,QAAQ,GAAGZ,aAAa,CAACU,CAAC,CAAC;MACjC,MAAMG,iBAAiB,GAAGH,CAAC,KAAKV,aAAa,CAACW,MAAM,GAAG,CAAC,GACpDC,QAAQ,KAAKjB,aAAa,CAACI,KAAK,CAACe,KAAK,CAACJ,CAAC,CAAC,CAAC,GAC1C,IAAI;MACRpB,MAAM,CACFU,aAAa,CAACU,CAAC,CAAC,KAAKX,KAAK,CAACW,CAAC,CAAC,IAAI,CAACG,iBAAiB,EACnD,MAAM,8CAA8C,GAChD,IAAIb,aAAa,gCAAgC,GACjD,UAAUD,KAAK,KAAK,CAAC;;;EAIjC,IAAI,CAACL,YAAY,CAACI,MAAM,CAAC,IAAI,CAACQ,KAAK,CAACC,OAAO,CAACT,MAAM,CAAC,EAAE;IACnDA,MAAM,GAAG,CAACA,MAAM,CAAa;;EAG/BC,KAAK,GAAGA,KAAK,IAAIC,aAAa;EAC9BF,MAAM,GAAGG,KAAK,KAAK,QAAQ,GACvBL,YAAY,CAACE,MAAM,EAAEG,KAAK,CAAC,GAC3BT,OAAO,CAACM,MAAkB,EAAE,EAAE,EAAE,IAAI,CAAa;EACrD,OAAOT,MAAM,CAACQ,UAAU,CAACC,MAAoB,EAAEC,KAAK,EAAEE,KAAK,CAAC;AAC9D","names":["ENGINE","assert","assertNonNegativeIntegerDimensions","flatten","inferDtype","isTypedArray","sizeFromShape","toTypedArray","makeTensor","values","shape","inferredShape","dtype","Error","channels","backend","createTensorFromTexture","Array","isArray","providedSize","inferredSize","i","length","inferred","flatDimsDontMatch","slice"],"sources":["/Users/joachimdemuth/node_modules/@tensorflow/tfjs-core/src/ops/tensor_ops_util.ts"],"sourcesContent":["/**\n * @license\n * Copyright 2018 Google LLC. All Rights Reserved.\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n * http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n * =============================================================================\n */\n\nimport {ENGINE} from '../engine';\nimport {Tensor} from '../tensor';\nimport {TensorLike, TypedArray, WebGLData} from '../types';\nimport {DataType} from '../types';\nimport {assert, assertNonNegativeIntegerDimensions, flatten, inferDtype, isTypedArray, sizeFromShape, toTypedArray} from '../util';\n\n/** This is shared code across all tensor creation methods. */\nexport function makeTensor(\n    values: TensorLike|WebGLData, shape: number[], inferredShape: number[],\n    dtype?: DataType): Tensor {\n  if (dtype == null) {\n    dtype = inferDtype(values);\n  }\n  if (dtype === 'complex64') {\n    throw new Error(\n        `Cannot construct a complex64 tensor directly. ` +\n        `Please use tf.complex(real, imag).`);\n  }\n  if (typeof values === 'object' && 'texture' in values) {\n    if (dtype !== 'float32' && dtype !== 'int32') {\n      throw new Error(\n          `Creating tensor from texture only supports ` +\n          `'float32'|'int32' dtype, while the dtype is ${dtype}.`);\n    }\n    values.channels = values.channels || 'RGBA';\n    return ENGINE.backend.createTensorFromTexture(\n        values, shape || inferredShape, dtype);\n  }\n  if (!isTypedArray(values) && !Array.isArray(values) &&\n      typeof values !== 'number' && typeof values !== 'boolean' &&\n      typeof values !== 'string') {\n    throw new Error(\n        'values passed to tensor(values) must be a number/boolean/string or ' +\n        'an array of numbers/booleans/strings, or a TypedArray');\n  }\n  // Verify that the shape matches the inferred shape.\n  if (shape != null) {\n    assertNonNegativeIntegerDimensions(shape);\n\n    const providedSize = sizeFromShape(shape);\n    const inferredSize = sizeFromShape(inferredShape);\n    assert(\n        providedSize === inferredSize,\n        () =>\n            `Based on the provided shape, [${shape}], the tensor should have ` +\n            `${providedSize} values but has ${inferredSize}`);\n\n    for (let i = 0; i < inferredShape.length; ++i) {\n      const inferred = inferredShape[i];\n      const flatDimsDontMatch = i === inferredShape.length - 1 ?\n          inferred !== sizeFromShape(shape.slice(i)) :\n          true;\n      assert(\n          inferredShape[i] === shape[i] || !flatDimsDontMatch,\n          () => `Error creating a new Tensor. Inferred shape ` +\n              `(${inferredShape}) does not match the provided ` +\n              `shape (${shape}). `);\n    }\n  }\n\n  if (!isTypedArray(values) && !Array.isArray(values)) {\n    values = [values] as number[];\n  }\n\n  shape = shape || inferredShape;\n  values = dtype !== 'string' ?\n      toTypedArray(values, dtype) :\n      flatten(values as string[], [], true) as string[];\n  return ENGINE.makeTensor(values as TypedArray, shape, dtype);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}